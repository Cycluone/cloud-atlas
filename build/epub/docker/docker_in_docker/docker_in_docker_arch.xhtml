<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Docker in Docker架构</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="docker-in-docker">
<span id="docker-in-docker-arch"></span><h1>Docker in Docker架构</h1>
<p>在开发测试环境，为了能够建立一个完整的 <a class="reference internal" href="../../kubernetes/index.xhtml#kubernetes"><span class="std std-ref">Kubernetes Atlas</span></a> 集群，使用大量的物理服务器是不经济的。最初我采用 <a class="reference internal" href="../../studio/kvm_docker_in_studio.xhtml#kvm-docker-in-studio"><span class="std std-ref">Studio环境KVM和Docker</span></a> 在一台物理主机上构建多个KVM虚拟机，然后再在虚拟机内部部署Docker来运行Kubernetes。</p>
<p>这种基于虚拟机运行的Kubernetes集群，在云计算厂商中较为流行，不过云计算厂商采用虚拟机的优势主要是：</p>
<ul class="simple">
<li><p>虚拟机强隔离，弥补了容器隔离不彻底的安全隐患</p></li>
<li><p>继承了KVM虚拟机的成熟技术，例如热迁移，以及大量的成熟调度、资源分配技术</p></li>
</ul>
<p>不过，对于测试环境以及内部使用的有安全保障的运行环境，嵌套KVM虚拟化和Docker容器带来了性能损耗。特别是个人电脑上模拟Kubernetes技术，大量的虚拟机资源消耗影响过大。</p>
<section id="id1">
<h2>Docker in Docker背景</h2>
<p><a class="reference external" href="https://store.docker.com/images/docker">Docker in Docker</a><span class="link-target"> [https://store.docker.com/images/docker]</span> 可以在一个Docker系统中运行Docker镜像，实现一个本地化Kubernetes集群。在2017年时，可以通过GitHub项目 <a class="reference external" href="https://github.com/Mirantis/kubeadm-dind-cluster">Mirantis/kubeadm-dind-cluster</a><span class="link-target"> [https://github.com/Mirantis/kubeadm-dind-cluster]</span> 来使用Docker in Docker设置一个Kubernetes集群。当然，你的底层Docker可以是运行在Linux上的Docker，也可以是macOS上的Docker Desktop。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><a class="reference external" href="https://github.com/Mirantis/kubeadm-dind-cluster">Mirantis/kubeadm-dind-cluster</a><span class="link-target"> [https://github.com/Mirantis/kubeadm-dind-cluster]</span> 已停止开发，建议采用 <a class="reference internal" href="kind_cluster.xhtml#kind-cluster"><span class="std std-ref">kind集群(Docker in Docker)</span></a> 来实现这个部署。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>和 <a class="reference internal" href="../../kubernetes/startup_prepare/install_run_minikube.xhtml#id1"><span class="std std-ref">minikube</span></a> 不同的是：minikube是一个单节点kubernetes，没有扩展性，只能做基本的命令操作。Docker in Docker提供了完整的在单个节点上运行多个Docker节点来实现多节点Kubernetes集群。除了没有物理服务器的冗灾，Docker in Docker可以模拟完整的Kubernetes集群，并且 <a class="reference internal" href="docker_in_docker_kind.xhtml#docker-in-docker-kind"><span class="std std-ref">Docker in Docker部署工具kind</span></a> 可以实现多集群模拟，以便能够测试不同的应用部署架构。</p>
</div>
<p>Docker in Docker 主要用于帮助Docker的开发，很多人用Docker in Docker来运行持续集成(CI，例如 Jenkins)。</p>
</section>
<section id="id4">
<h2>参考</h2>
<ul class="simple">
<li><p><a class="reference external" href="https://callistaenterprise.se/blogg/teknik/2017/12/20/kubernetes-on-docker-in-docker/">Setting up a Kubernetes cluster using Docker in Docker</a><span class="link-target"> [https://callistaenterprise.se/blogg/teknik/2017/12/20/kubernetes-on-docker-in-docker/]</span></p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>