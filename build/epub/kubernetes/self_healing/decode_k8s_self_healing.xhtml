<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>解码Kubernetes自愈</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="kubernetes">
<span id="decode-k8s-self-healing"></span><h1>解码Kubernetes自愈</h1>
<p>虽然Kubernetes提供了应用的自愈(pod self-healing)，但是除了管控节点(master)，计算工作节点并没有提供自身修复能力。也就是说，如果要构建可一个高可靠的Kubernetes集群，需要实现工作节点的自我修复，需要结合第三方解决方案。</p>
<p>比较理想的状态是结合虚拟化云计算：虚拟化云计算提供了自动修复(热迁移或者迅速重建完全一致的虚拟机)，这样可以实现Kubernetes节点的自愈。对于Kubernetes来说，其底层架构就是完全可靠的基础架构。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>仔细思考一下，Kubernetes确实只聚焦在应用的高可用上，随时会为失败的应用程序拉起一个应用副本。但是Kubernetes并没有解决自身节点的高可用，仅仅是将node标记为 <code class="docutils literal notranslate"><span class="pre">NotReady</span></code> 。</p>
<p>而底层提供自动化自愈架构，我们称之为 <code class="docutils literal notranslate"><span class="pre">provision</span></code> (供应商)，提供Kubernetes故障节点的自动下线，修复，自动上线功能。</p>
</div>
<p>要达到集群自愈，需要基础架构在Kubernetes之前实现可用且可自愈，这样的基础架构才能保障上层的Kubernetes始终平稳运行。通常这种基础架构由云计算来实现，例如VMware或者 <a class="reference internal" href="../../openstack/index.xhtml#openstack"><span class="std std-ref">OpenStack Atlas</span></a> 。</p>
<p>Kublr这样的平台提供了原生的基础架构和能力来自动提供，伸缩和修复。自动伸缩的能力可以自动设置每个节点、worker和master。它提供了基础架构可以在虚拟机宕机时自动恢复成另一个虚拟机。Kublr也同时监控所有事件确保替换的虚拟机能够自动启动并重新连接到Kubernetes集群，不需要任何人工干预。</p>
<p>上述主机实例，不论是虚拟机还是物理服务器，对于Kublr都是相同的处理方式，即在服务器节点运行Kublr agent，来确保每个节点都运行在指定状态。agent监控节点以及节点上的组件确保组件正常工作，同时确保工作节点(worker)和管控节点(master)能安全通讯以及不同组件安全连接。</p>
<section id="id1">
<h2>参考</h2>
<ul class="simple">
<li><p><a class="reference external" href="https://devops.com/decoding-the-self-healing-kubernetes/">Decoding the Self-Healing Kubernetes</a><span class="link-target"> [https://devops.com/decoding-the-self-healing-kubernetes/]</span></p></li>
<li><p><a class="reference external" href="https://www.msystechnologies.com/blog/decoding-the-self-healing-kubernetes-step-by-step-2/">Decoding the Self-Healing Kubernetes:Step by Step</a><span class="link-target"> [https://www.msystechnologies.com/blog/decoding-the-self-healing-kubernetes-step-by-step-2/]</span></p></li>
<li><p><a class="reference external" href="https://kublr.com/blog/reliable-self-healing-kubernetes-explained/">Reliable, Self-Healing Kubernetes Explained</a><span class="link-target"> [https://kublr.com/blog/reliable-self-healing-kubernetes-explained/]</span></p></li>
<li><p><a class="reference external" href="https://jaxenter.com/kubernetes-self-healing-nodes-163501.html">True reliability requires self-healing nodes and infrastructure management</a><span class="link-target"> [https://jaxenter.com/kubernetes-self-healing-nodes-163501.html]</span></p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>