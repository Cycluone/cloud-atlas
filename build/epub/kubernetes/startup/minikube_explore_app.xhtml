<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>在Minikube中探索应用</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="minikube">
<span id="minikube-explore-app"></span><h1>在Minikube中探索应用</h1>
<section id="kubernetes-pods">
<h2>Kubernetes Pods概念</h2>
<p>当我们 <a class="reference internal" href="minikube_deploy_app.xhtml#minikube-deploy-app"><span class="std std-ref">使用Minikube集群部署应用</span></a> ，Kubernetes创建了一个承载应用实例的 <code class="docutils literal notranslate"><span class="pre">Pod</span></code> 。所谓Pod就是Kubernetes抽象出来，用于表示一组包含一个或多个应用容器（例如Docker或rkt），以及一些共享给这些容器的资源。这些资源包括:</p>
<ul class="simple">
<li><p>共享存储，例如Volume卷</p></li>
<li><p>共享网络，具有一个唯一的集群IP地址</p></li>
<li><p>有关如何运行每个容器的信息，例如容器镜像的版本或者使用的特殊端口</p></li>
</ul>
<p>一个Pod能给一个特定应用 “逻辑主机” 模式，并且可以包含不同的应用容器，例如这些容器有相关性。举例，一个Pod可能会包含运行Node.js应用的容器以及一个将数据发送个Node.js web服务器的容器。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>在一个Pod中的所有容器 <code class="docutils literal notranslate"><span class="pre">共享</span></code> <strong>同一个IP地址以及端口范围</strong> ，并且总是一起调度和分发，这样可以保证同一个Pod的相关所有容器都运行在一个相同Node节点上。</p>
<p>你可以将Pod视为一个逻辑主机，这个逻辑主机中多个容器实际上就是这个主机上运行的多个进程，只不过进程间通过 namespace 和 cgroup 进行了良好隔离。这个逻辑主机可以在不同Node之间迁移，则这个逻辑主机中所有相关容器（进程）也就共同迁移。正是因为Pod是一个逻辑主机，所以只有一个IP地址和一个端口范围。</p>
<p>当然，如果你以前学习过Docker概念，对Docker把容器比喻成集装箱的概念印象深刻的话，你可以继续把容器container想像成集装箱，但是是小尺寸集装箱。而包含多个容器的Pod就是一个大尺寸的集装箱，里面装了几个小集装箱（容器）。所以每次调度Pod的时候就是一起调度多个小集装箱（相关容器）。</p>
<p>Pod 是Kubernetes平台的原子单位。当我们在Kubernetes中创建一个部署，这个部署将创建Pod并在Pod中运行容器。每个Pod会运行在调度到的Node节点上，并保持持续运行，直到Pod被终止（根据重启策略）或删除。当出现Node故障时，故障的Pod会被调度到集群其他正常节点上继续运行。</p>
</div>
<section id="pod">
<h3>Pod概览</h3>
<figure class="align-default">
<img alt="../../_images/kubernetes_pods.svg" src="../../_images/kubernetes_pods.svg" /></figure>
<ul class="simple">
<li><p>Pod可以包含一个或多个 containerd app</p></li>
<li><p>Pod可以包含一个或多个（共享的）volume</p></li>
<li><p>一个Pod只有一个IP地址，这个IP地址是Pod中所有容器共享的</p></li>
</ul>
</section>
</section>
<section id="kubernetes-nodes">
<h2>Kubernetes Nodes概念</h2>
<p>Pod总是运行在Node上。所谓Node就是在Kubernetes集群中的工作服务器，可以是虚拟机也可以是物理服务器。所有的Node节点都是由Master管理的。一个Node节点可以运行多个Pods，并且Kubernetes master会自动处理调度，以便将pods分布到整个集群。Master自动调度任务会对每个节点的可用资源进行记账。</p>
<p>每个Kubernetes Node至少具有:</p>
<ul class="simple">
<li><p>Kubelet: 负责在Kubernetes Master和Node之间通讯，负责管理主机上的Pod和容器。</p></li>
<li><p>一个容器运行时（container runtime)，例如 Docker, rkt : 负责从镜像中心（registry）拉取容器镜像，解包容器，并运行应用程序</p></li>
</ul>
<section id="node">
<h3>Node概览</h3>
<figure class="align-default">
<img alt="../../_images/minikube_nodes.svg" src="../../_images/minikube_nodes.svg" /></figure>
</section>
</section>
<section id="kubectl">
<h2>使用kubectl排查问题</h2>
<p>常用的kubectl命令如下:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">kubectl</span> <span class="pre">get</span></code> - 列出资源</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kubectl</span> <span class="pre">describe</span></code> - 显示一个资源的详细信息</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kubectl</span> <span class="pre">logs</span></code> - 打印一个pod中的某个容器的日志</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kubectl</span> <span class="pre">exec</span></code> - 执行一个pod中某个容器中的命令</p></li>
</ul>
<section id="id1">
<h3>kubectl排查案例</h3>
<ul>
<li><p>首先检查Deployment是否成功部署了pod:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kubectl</span> <span class="n">get</span> <span class="n">pods</span>
</pre></div>
</div>
</li>
<li><p>然后通过 <code class="docutils literal notranslate"><span class="pre">describe</span></code> 命令检查pod的详细信息:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kubectl</span> <span class="n">describe</span> <span class="n">pods</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><code class="docutils literal notranslate"><span class="pre">kubectl</span> <span class="pre">describe</span></code> 可以详细观察Pod的容器: IP地址，Pod的生命周期相关事件。这个describe输出非常方便阅读</p>
</div>
<ul>
<li><p>由于Kubernetes私有网络外部无法访问，则需要启动 <code class="docutils literal notranslate"><span class="pre">kubectl</span> <span class="pre">proxy</span></code> ，然后才能访问服务:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>kubectl proxy

export POD_NAME=$(kubectl get pods -o go-template --template &#39;{{range .items}}{{.metadata.name}}{{&quot;\n&quot;}}{{end}}&#39;)

curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/
</pre></div>
</div>
</li>
</ul>
<p>同上案例就可以访问Pod上运行Nginx服务。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>请注意Kubernetes私有网络在外部无法访问，我们需要通过 <a class="reference internal" href="minikube_expose_app.xhtml#minikube-expose-app"><span class="std std-ref">Minikube对外输出应用</span></a> 。</p>
</div>
</section>
</section>
<section id="id2">
<h2>参考</h2>
<ul class="simple">
<li><p><a class="reference external" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/">Viewing Pods and Nodes</a><span class="link-target"> [https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/]</span></p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>