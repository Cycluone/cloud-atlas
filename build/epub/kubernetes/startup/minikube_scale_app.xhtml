<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Minikube的应用部署伸缩</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="minikube">
<span id="minikube-scale-app"></span><h1>Minikube的应用部署伸缩</h1>
<p>虽然在 <a class="reference internal" href="minikube_deploy_app.xhtml#minikube-deploy-app"><span class="std std-ref">使用Minikube集群部署应用</span></a> 后通过 <a class="reference internal" href="minikube_expose_app.xhtml#minikube-expose-app"><span class="std std-ref">Minikube对外输出应用</span></a> 能够让外部访问到应用服务，但是可以发现，这样的部署只有一个Pod在运行应用程序。当系统负载流量增加时，单个Pod是无法支持业务的，这就需要使用Kubernetes的横向扩展能力。</p>
<p><strong>Scaling</strong> 是通过修改Deployment的部署副本replicas来实现的。</p>
<section id="scaling">
<h2>伸缩(Scaling)概览</h2>
<figure class="align-default">
<img alt="../../_images/kubernetes_scaling.svg" src="../../_images/kubernetes_scaling.svg" /></figure>
<p>部署的伸缩是通过在可用资源上调度,创建新的Pod或删除运行的Pod来实现的，Kubernetes将按指定Pod数量增加或缩减Pod以提供恰当的负载能力。当具有多个应用程序运行实例(Pods)时，不仅具有更大的负载能力，也能够实现滚动升级而不影响系统。</p>
</section>
<section id="id1">
<h2>伸缩应用</h2>
<p>我们在 <a class="reference internal" href="minikube_deploy_app.xhtml#minikube-deploy-app"><span class="std std-ref">使用Minikube集群部署应用</span></a> 中部署了Pod，名为 <code class="docutils literal notranslate"><span class="pre">my-dev</span></code> ，现在我们来扩展这个应用。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>请注意，我的案例和 <a class="reference external" href="https://kubernetes.io/docs/tutorials/">Google提供的在线教程</a><span class="link-target"> [https://kubernetes.io/docs/tutorials/]</span> 不同，我采用了从 <a class="reference external" href="https://hub.docker.com/_/ubuntu">Ubuntu Docker官方镜像</a><span class="link-target"> [https://hub.docker.com/_/ubuntu]</span> 从头开始定制镜像内容，所以初始的 <code class="docutils literal notranslate"><span class="pre">my-dev</span></code> 容器已经做了一定的内容修改（相当于自己做了一个和Google案例相同的容器），这样就需要把容器转换（存储）成自定义镜像，然后通过自定义镜像来重新部署应用。</p>
</div>
<section id="id2">
<h3>部署私有镜像仓库</h3>
<p>请参考 <a class="reference internal" href="../deployment/docker_registry.xhtml#docker-registry"><span class="std std-ref">在Kubernetes中部署私有Docker镜像仓库</span></a> 部署私有镜像仓库，通过私有镜像仓库，我们可以把前期自定义容器转换成镜像，并用自定义镜像创建我们需要的容器集群。</p>
</section>
</section>
<section id="id3">
<h2>参考</h2>
<ul class="simple">
<li><p><a class="reference external" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/scale/scale-intro/">Scale Your App</a><span class="link-target"> [https://kubernetes.io/docs/tutorials/kubernetes-basics/scale/scale-intro/]</span></p></li>
<li></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>