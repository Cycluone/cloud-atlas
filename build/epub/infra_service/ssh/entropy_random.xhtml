<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>熵和随机数</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="entropy-random">
<span id="id1"></span><h1>熵和随机数</h1>
<section id="entropy">
<h2>熵(entropy)</h2>
<p>熵池是指当前系统的环境噪声，熵指系统的混乱程度。生成SSH密钥时，确保系统中存在足够不可预测的熵( <code class="docutils literal notranslate"><span class="pre">unpredictable</span> <span class="pre">entropy</span></code> )非常重要。</p>
<p>在Internet上曾经发生过由于没有足够的随机生成的服务器密钥导致数千设备使用了相同的主机密钥。</p>
<p>强烈建议在安装操作系统时收集随机数据，并将随机数据保存到种子文件。然后重新启动系统，在启动过程中再次收集更多的随机数据，然后混合两次采集的随机数据，最后在根据混合后的随机数据来生成主机密钥。这样可以最大程度利用随机性，并确保定期对随机种子文件进行更新，尤其在确保生成SSH主机密钥后对其更新。</p>
<p>很多现代化通用CPU提供了硬件随机数生成器，对解决上述问题很有帮助。最佳时间是结合多种方式收集 <code class="docutils literal notranslate"><span class="pre">熵</span></code> ，将这些熵保存在随机种子文件中，并从硬件随机数生成器中混合一些熵。这样即使其中之一受到某种程度对损害(例如硬件安全漏洞)，另一个随机数据源也能确保密钥安全。</p>
<section id="ssl">
<h3>SSL和熵</h3>
<p>有时候服务器会出现一些非常古怪的SSL问题，非常隐秘的 <code class="docutils literal notranslate"><span class="pre">熵</span></code> 可能有所关联 - <a class="reference internal" href="../../docker/admin/debug_docker_ssh_crash.xhtml#debug-docker-ssh-crash"><span class="std std-ref">排查Docker容器ssh服务Crash</span></a></p>
</section>
</section>
<section id="linux">
<h2>Linux中随机数设备</h2>
<p>Linux系统中有2个随机数生成设备文件：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/dev/random</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/dev/urandom</span></code></p></li>
</ul>
<p>上述两个设备是利用系统的熵池来计算出一定数量的随机比特，然后将随机比特作为字节流返回。</p>
<p><code class="docutils literal notranslate"><span class="pre">/dev/random</span></code> 的random pool依赖于系统中断，所以在系统中断不足时， <code class="docutils literal notranslate"><span class="pre">/dev/random</span></code> 会一直阻塞，这样就会导致读取这个设备的进程进入等待，直到系统的中断数足够。虽然 <code class="docutils literal notranslate"><span class="pre">/dev/random</span></code> 通常性能较差(受限于中断数量)，但是 <code class="docutils literal notranslate"><span class="pre">/dev/random</span></code> 生成的随机性要好于 <code class="docutils literal notranslate"><span class="pre">/dev/urandom</span></code> 设备。</p>
<p><code class="docutils literal notranslate"><span class="pre">/dev/urandom</span></code> 设备的 <code class="docutils literal notranslate"><span class="pre">u</span></code> 前缀表示 <code class="docutils literal notranslate"><span class="pre">ublock</span></code> ，也就是在不能产生足够的随机性数据时也不会阻塞程序。这也意味着生成的随机性效果不佳，好处是快速。</p>
<p>对于加密解密应用来说， <code class="docutils literal notranslate"><span class="pre">/dev/urandom</span></code> 设备的随机性不够，所以通常不是好的选择。但是 <code class="docutils literal notranslate"><span class="pre">/dev/random</span></code> 性能也可能满足不了速度要求。</p>
</section>
<section id="random">
<h2>测试 random 性能</h2>
</section>
<section id="id2">
<h2>参考</h2>
<ul class="simple">
<li><p><a class="reference external" href="http://kuanghy.github.io/2015/12/30/dev-random">Linux 中的随机数设备文件</a><span class="link-target"> [http://kuanghy.github.io/2015/12/30/dev-random]</span></p></li>
<li><p><a class="reference external" href="https://www.ssh.com/ssh/keygen/">ssh-keygen - Generate a New SSH Key</a><span class="link-target"> [https://www.ssh.com/ssh/keygen/]</span></p></li>
<li><p><a class="reference external" href="https://major.io/2007/07/01/check-available-entropy-in-linux/">Check available entropy in Linux</a><span class="link-target"> [https://major.io/2007/07/01/check-available-entropy-in-linux/]</span></p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>